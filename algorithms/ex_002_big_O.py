"""
Правило 1: Время выполнения как функция от количества операций
Если алгоритму нужно выполнить определённое количество операций,
например f(N), то его временная сложность будет O(f(N)).
"""


def example_1(n):
    """В этом примере функция example_1 выполняет n операций
    (в данном случае — это печать чисел). Следовательно, её временная
    сложность — O(n)."""
    for i in range(n):
        print(i)


"""
Правило 2: Сложность последовательных операций
Если алгоритм выполняет одну операцию с O(f(N)) шагов, затем другую операцию с
O(g(N)) шагов, то общая сложность будет O(f(N) + g(N)).
"""


def example_2(n):
    """Здесь первая операция имеет сложность O(n), а вторая — O(n^2).
    Общая сложность будет O(n + n^2), но так как n^2 доминирует,
    сложность упрощается до O(n^2)."""
    # Операция 1: Выполнение n шагов
    for i in range(n):
        print(i)

    # Операция 2: Выполнение n^2 шагов
    for i in range(n):
        for j in range(n):
            print(i, j)


"""
Правило 3: Упрощение выражений для сложностей
Если алгоритм выполняет O(f(N) + g(N)) шагов и f(N) больше по порядку роста,
чем g(N), то сложность можно упростить до O(f(N)).
"""


def example_3(n):
    # O(n)
    for i in range(n):
        print(i)

    # O(n^2)
    for i in range(n):
        for j in range(n):
            print(i, j)


"""
Правило 4: Вложенные операции
Если алгоритму нужно выполнить O(f(N)) операций, и в каждой из этих операций
нужно выполнить ещё O(g(N)) шагов, общая сложность будет O(f(N) * g(N)).
"""


def example_4(n):
    """Здесь у нас есть внешний цикл с O(n) итерациями,
    и внутренний цикл тоже с O(n) итерациями.
    Общая сложность будет O(n * n), что упрощается до O(n^2)."""
    for i in range(n):       # O(n)
        for j in range(n):   # O(n) внутри каждого из O(n) шагов
            print(i, j)


"""
Правило 5: Пренебрежение константами
Постоянными множителями можно пренебречь.
Если у нас есть константа C, то O(C * f(N)) или O(f(C * N))
можно упростить до O(f(N))."""


def example_5(n):
    """Здесь мы умножаем количество шагов на 2,
    но это не влияет на порядок роста.
    Следовательно, сложность остаётся O(n)."""
    # O(2 * n)
    for i in range(2 * n):
        print(i)
