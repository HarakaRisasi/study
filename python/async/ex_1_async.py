"""
Асинхронный код на Python: синтаксис и особенности

```python
import asyncio
import time
```

Особенности выполнения кода в Python

Современные процессоры с несколькими ядрами действительно могут обрабатывать несколько операций одновременно. 
Однако стандартная реализация Python (CPython) имеет глобальную блокировку интерпретатора (GIL), 
которая разрешает выполнение только одного потока Python в любой момент времени. 
Это ограничение связано с особенностями управления памятью в CPython.

Типы операций по характеру нагрузки

1. CPU-bound операции – задачи, скорость выполнения которых ограничена производительностью процессора 
(например, сложные математические вычисления).

2. IO-bound операции – задачи, скорость выполнения которых ограничена скоростью подсистемы ввода-вывода 
(например, запросы к сети, чтение файлов, обращение к базе данных).

Асинхронность как решение для IO-bound задач

Для эффективной работы с IO-bound операциями в Python используется асинхронное программирование. 
Вместо того чтобы блокировать выполнение программы на время ожидания ответа, 
код может переключаться на другие задачи.

Ключевые компоненты асинхронности

1. Event Loop (цикл событий) – планировщик, который управляет выполнением асинхронных задач. 
Он переключается между ними в моменты ожидания.

2. Корутины (coroutines) – специальные функции, определяемые с помощью `async def`. 
Они могут приостанавливать своё выполнение и возобновлять его позже.

3. Ключевое слово `await` – используется для приостановки выполнения корутины до завершения асинхронной операции.

Правила использования:
- Функция, содержащая `await`, должна быть объявлена с `async def`.
- Корутины не выполняются напрямую – их нужно запускать через event loop.
"""

import asyncio
import time


async def say_after(delay, message):
    """Корутина, которая выводит сообщение после задержки.
    Пояснение работы кода:

    1. `asyncio.run(main())` – создаёт и запускает event loop.
    2. `asyncio.create_task()` – планирует выполнение корутины как задачи.
    3. `await asyncio.sleep()` – не блокирует поток, а позволяет event loop переключиться на другие задачи.
    4. Несмотря на разную длительность задержек (3 и 2 секунды), обе задачи выполнятся примерно за 3 секунды,
        а не за 5, благодаря параллельному выполнению.

    Вывод программы:

    Начало выполнения: 14:30:00
    Мир!  # Через 2 секунды
    Привет # Через 3 секунды
    Завершение: 14:30:03
    """
    await asyncio.sleep(delay)  # Неблокирующая задержка
    print(message)


async def main():
    print(f"Начало выполнения: {time.strftime('%H:%M:%S')}")

    # Создаём задачи для параллельного выполнения
    task1 = asyncio.create_task(say_after(3, "Привет"))
    task2 = asyncio.create_task(say_after(2, "Мир!"))

    # Ждём завершения обеих задач
    await task1
    await task2

    print(f"Завершение: {time.strftime('%H:%M:%S')}")


# Запуск event loop и корутины main
asyncio.run(main())